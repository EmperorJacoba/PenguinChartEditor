using UnityEngine;
using TMPro;
using System.Collections.Generic;
using System;
using UnityEngine.EventSystems;
using System.Linq;

public class BPM : Label<(float, float)>
{
    public static HashSet<int> SelectedBPMEvents { get; set; }
    bool selectionActionsEnabled = false;
    public override HashSet<int> GetSelectedEvents()
    {
        return SelectedBPMEvents;
    }

    void Awake()
    {
        inputMap = new();
        inputMap.Enable();

        if (!selectionActionsEnabled)
        {
            inputMap.Charting.Delete.performed += x => DeleteSelection();
            inputMap.Charting.Copy.performed += x => CopySelection();
            inputMap.Charting.Paste.performed += x => PasteSelection();
            selectionActionsEnabled = true;
        }
    }

    public override void HandleManualEndEdit(string newVal)
    {
        try
        {
            SongTimelineManager.TempoEvents[Tick] = (ProcessUnsafeBPMString(newVal), SongTimelineManager.TempoEvents[Tick].Item2);
        }
        catch
        {
            return;
        }

        SongTimelineManager.RecalculateTempoEventDictionary(Tick);

        BeatlinePreviewer.editMode = true;
        ConcludeManualEdit();
    }

    public override SortedDictionary<int, (float, float)> GetEventClipboard()
    {
        return bpmClipboard;
    }

    public override SortedDictionary<int, (float, float)> GetTargetEventSet()
    {
        return SongTimelineManager.TempoEvents;
    }

    public override void PasteSelection()
    {
        var startPasteTick = BeatlinePreviewer.currentPreviewTick;
        
        // Check each individual clipboard for events to paste
        if (bpmClipboard.Count > 0)
        {
            var endBPMPasteTick = bpmClipboard.Keys.Max() + startPasteTick; // Get selection zone to overwrite
            // Find events that will not be overwritten to preserve
            SortedDictionary<int, (float, float)> tempTempoEventDictionary = GetNonOverwritableDictEvents(SongTimelineManager.TempoEvents, startPasteTick, endBPMPasteTick);

            // Write selected events to combine with existing events
            foreach (var tick in bpmClipboard)
            {
                tempTempoEventDictionary.Add(tick.Key + startPasteTick, (bpmClipboard[tick.Key].Item1, 0)); // 0 is a placeholder that will be overwritten (timestamp is irrelevant here because dictionary is not read yet)
            }
            SongTimelineManager.TempoEvents = tempTempoEventDictionary;

            // Recalculate to replace 0 timestamps with correct timestamps
            // Find the tick event BEFORE the first pasted tick-time to avoid using the zero placeholder as the starting point
            // If recalculation starts from the first event then the calculations start from zero and two sets of beatlines appear
            SongTimelineManager.RecalculateTempoEventDictionary(SongTimelineManager.FindLastTempoEventTickExclusive(startPasteTick));
        }
    }

    public override void DeleteSelection()
    {
        var selection = GetSelectedEvents();
        var targetEventSet = GetTargetEventSet();

        if (selection.Count != 0)
        {
            var earliestTick = selection.Min();
            foreach (var tick in selection)
            {
                if (tick != 0)
                {
                    targetEventSet.Remove(tick);
                }
            }
            SongTimelineManager.RecalculateTempoEventDictionary(SongTimelineManager.FindLastTempoEventTickInclusive(earliestTick));
        }
        selection.Clear();

        TempoManager.UpdateBeatlines();
    }

    SortedDictionary<int, (float, float)> bpmClipboard;

    /// <summary>
    /// Take a BPM string generated by user and turn it into a dictionary-safe float value
    /// </summary>
    /// <param name="newBPM"></param>
    /// <returns></returns>
    float ProcessUnsafeBPMString(string newBPM)
    {
        var bpmAsFloat = float.Parse(newBPM);
        if (bpmAsFloat == 0 || bpmAsFloat > 1000.0f)
        {
            return SongTimelineManager.TempoEvents[Tick].Item1;
        }
        bpmAsFloat = (float)Math.Round(bpmAsFloat, 3);
        return bpmAsFloat;
    }

    public void HandleDragEvent(BaseEventData data)
    {
        var clickdata = (PointerEventData)data;

        if (Tick == 0) return;
        if (!Input.GetKey(KeyCode.LeftControl)) return;

        ChangeBPMPositionFromDrag(clickdata.delta.y);
    }

    /// <summary>
    /// Change the data associated with a beatline event based on a click + drag from the user.
    /// </summary>
    /// <param name="mouseDelta">The difference between the mouse on this frame versus the last frame.</param>
    private void ChangeBPMPositionFromDrag(float mouseDelta)
    {
        WaveformManager.GetCurrentDisplayedWaveformInfo(out var _, out var _, out var timeShown, out var _, out var _);

        var percentOfScreenMoved = mouseDelta / Screen.height; // CHECK THIS
        var timeChange = percentOfScreenMoved * timeShown;

        // Use exclusive function because this needs to find the tempo event before this beatline's tempo event.
        // Inclusive would always return the same event, which causes 0/0 and thus NaN.
        var lastBPMTick = SongTimelineManager.FindLastTempoEventTickExclusive(Tick);

        var newTime = SongTimelineManager.TempoEvents[Tick].Item2 + (float)timeChange;

        // time is measured in seconds so this is beats per second, multiply by 60 to convert to BPM
        // Calculate the new BPM based on the time change
        float newBPS = ((Tick - lastBPMTick) / (float)ChartMetadata.ChartResolution) / (newTime - SongTimelineManager.TempoEvents[lastBPMTick].Item2);
        float newBPM = (float)Math.Round((newBPS * 60), 3);

        if (newBPM < 0 || newBPM > 1000) return; // BPM can't be negative and event selection gets screwed with when the BPM is too high

        // Write new data: time changes for this beatline's tick, BPM changes for the last tick event.
        SongTimelineManager.TempoEvents[Tick] = (SongTimelineManager.TempoEvents[Tick].Item1, newTime);
        SongTimelineManager.TempoEvents[lastBPMTick] = (newBPM, SongTimelineManager.TempoEvents[lastBPMTick].Item2);

        // Update rest of dictionary to account for the time change.
        SongTimelineManager.RecalculateTempoEventDictionary(Tick, (float)timeChange);

        // Display the changes
        TempoManager.UpdateBeatlines();
    }
}