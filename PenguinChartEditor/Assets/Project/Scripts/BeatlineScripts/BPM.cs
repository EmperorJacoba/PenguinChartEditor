using UnityEngine;
using System.Collections.Generic;
using System;
using UnityEngine.EventSystems;
using System.Linq;

public class BPM : Label<BPMData>
{
    const int SECONDS_PER_MINUTE = 60;

    #region Event Sets
    /// <summary>
    /// Dictionary that contains tempo changes and corresponding tick time positions. 
    /// <para> Key = Tick-time position. Value = See BPMData struct</para>
    /// <remarks>When writing to file, multiply BPMChange value by 100 to get proper .chart format (where example would show as 192 = B 102201)</remarks>
    /// </summary>
    public static SortedDictionary<int, BPMData> Events { get; set; } = new();

    public override SortedDictionary<int, BPMData> GetEvents()
    {
        return Events;
    }

    public override void SetEvents(SortedDictionary<int, BPMData> newEvents)
    {
        var breakKey = GetFirstVariableEvent(newEvents);
        Events = newEvents;

        // Safety check before recalculating dictionary
        // When pasting into dictionary, tick 0 might inherit data
        // from a pasted event that has a timestamp which is not 0.
        // Tick 0's timestamp is always 0
        if (Events[0].Timestamp != 0)
        {
            Events[0] = new BPMData(Events[0].BPMChange, 0);
        }

        if (breakKey != -1)
        {
            RecalculateTempoEventDictionary(GetLastTempoEventTickExclusive(breakKey));
        }
    }

    public int GetFirstVariableEvent(SortedDictionary<int, BPMData> newData)
    {
        var currentKeys = Events.Keys.ToHashSet();
        currentKeys.UnionWith(newData.Keys.ToHashSet());
        currentKeys.OrderBy(x => x);

        foreach (var key in currentKeys)
        {
            try
            {
                if (newData[key] != Events[key]) // Data has been edited at this point
                {
                    return key;
                }
            }
            catch // The key cannot be accessed in one of the dictionaries (addition/removal)
            {
                return key;
            }
        }
        return -1; // No discrepency
    }

    public static HashSet<int> SelectedBPMEvents { get; set; } = new();
    public override HashSet<int> GetSelectedEvents()
    {
        return SelectedBPMEvents;
    }

    SortedDictionary<int, BPMData> bpmClipboard = new();
    public override SortedDictionary<int, BPMData> GetEventClipboard()
    {
        return bpmClipboard;
    }

    #endregion

    #region Unity Functions

    // This is currently a temporary solution
    // to avoid multiple objects doing edit actions
    // in response to the same trigger
    // Move to dedicated script in future!
    static bool selectionActionsEnabled = false;
    void Awake()
    {
        inputMap = new();
        inputMap.Enable();

        if (!selectionActionsEnabled)
        {
            inputMap.Charting.Delete.performed += x => DeleteSelection();
            inputMap.Charting.Copy.performed += x => CopySelection();
            inputMap.Charting.Paste.performed += x => PasteSelection();
            inputMap.Charting.Cut.performed += x => CutSelection();
            selectionActionsEnabled = true;
        }
    }

    #endregion

    #region Event Handlers

    public override void PasteSelection() => ExecuteWithRecalculate(base.PasteSelection);
    public override void DeleteSelection() => ExecuteWithRecalculate(base.DeleteSelection);
    public override void CreateEvent(int newTick, BPMData newData) => ExecuteWithRecalculate(() => base.CreateEvent(newTick, newData));
    public override void CutSelection() => ExecuteWithRecalculate(base.CutSelection);

    void ExecuteWithRecalculate(Action action)
    {
        action();
        FinishEventAction();
    }

    void FinishEventAction()
    {
        RecalculateTempoEventDictionary();
        TempoManager.UpdateBeatlines();
    }

    public override void HandleManualEndEdit(string newVal)
    {
        try
        {
            Events[Tick] = new BPMData(ProcessUnsafeBPMString(newVal), Events[Tick].Timestamp);
        }
        catch
        {
            return;
        }

        RecalculateTempoEventDictionary(Tick);


        ConcludeManualEdit();
    }

    public override void HandleDragEvent(BaseEventData data)
    {
        var clickdata = (PointerEventData)data;

        if (Tick == 0) return;
        if (!Input.GetKey(KeyCode.LeftControl)) return;

        ChangeBPMPositionFromDrag(clickdata.delta.y);
    }

    #endregion

    #region Conversions

    /// <summary>
    /// Take a BPM string generated by user and turn it into a dictionary-safe float value
    /// </summary>
    /// <param name="newBPM"></param>
    /// <returns></returns>
    float ProcessUnsafeBPMString(string newBPM)
    {
        var bpmAsFloat = float.Parse(newBPM);
        if (bpmAsFloat == 0 || bpmAsFloat > 1000.0f)
        {
            return Events[Tick].BPMChange;
        }
        bpmAsFloat = (float)Math.Round(bpmAsFloat, 3);
        return bpmAsFloat;
    }

    public override string ConvertDataToPreviewString()
    {
        return $"{Events[Tick].BPMChange}";
    }

    /// <summary>
    /// Take a number of seconds (in S.ms form - ex. 61.1 seconds) and convert it to MM:SS.mmm format (where 61.1 returns 01:01.100)
    /// </summary>
    /// <param name="position">The unformatted second count.</param>
    /// <returns>The formatted MM:SS:mmm timestamp of the second position</returns>
    public static string ConvertSecondsToTimestamp(double position)
    {
        var minutes = Math.Floor(position / 60);
        var secondsWithMS = position - minutes * 60;
        var seconds = (int)Math.Floor(secondsWithMS);
        var milliseconds = Math.Round(secondsWithMS - seconds, 3) * 1000;

        string minutesString = minutes.ToString();
        if (minutes < 10)
        {
            minutesString = minutesString.PadLeft(minutesString.Length + 1, '0');
        }

        string secondsString = seconds.ToString();
        if (seconds < 10)
        {
            secondsString = secondsString.PadLeft(2, '0');
        }

        string millisecondsString = milliseconds.ToString();
        if (millisecondsString.Length < 3)
        {
            millisecondsString = millisecondsString.PadRight(3, '0');
        }

        return minutesString + ":" + secondsString + "." + millisecondsString;
    }

    public static int ConvertSecondsToTickTime(float timestamp)
    {
        if (timestamp <= 0)
            return 0;

        else if (timestamp > PluginBassManager.SongLength)
            return SongTimelineManager.SongLengthTicks;

        // Get parallel lists of the tick-time events and time-second values so that value found with seconds can be converted to a tick-time event
        var tempoTickTimeEvents = Events.Keys.ToList();
        var tempoTimeSecondEvents = Events.Values.Select(x => x.Timestamp).ToList();

        // Attempt a binary search for the current timestamp, 
        // which will return a bitwise complement of the index of the next highest timesecond value 
        // OR tempoTimeSecondEvents.Count if there are no more elements
        var index = tempoTimeSecondEvents.BinarySearch(timestamp);

        int lastTickEvent;
        if (index <= 0) // bitwise complement is negative or zero
        {
            // modify index if the found timestamp is at the end of the array (last tempo event)
            if (~index == tempoTimeSecondEvents.Count) index = tempoTimeSecondEvents.Count - 1;
            // else just get the index proper 
            else index = ~index - 1; // -1 because ~index is the next timestamp AFTER the start of the window, but we need the one before to properly render beatlines
            try
            {
                lastTickEvent = tempoTickTimeEvents[index];
            }
            catch
            {
                lastTickEvent = tempoTickTimeEvents[0]; // if ~index - 1 is -1, then the index should be itself
            }
        }
        else
        {
            lastTickEvent = tempoTickTimeEvents[index];
        }

        // Rearranging of .chart format specification distance between two ticks - thanks, algebra class!
        return Mathf.RoundToInt((ChartMetadata.ChartResolution * Events[lastTickEvent].BPMChange * (float)(timestamp - Events[lastTickEvent].Timestamp) / SECONDS_PER_MINUTE) + lastTickEvent);
    }

    public static double ConvertTickTimeToSeconds(int ticktime)
    {
        var lastTickEvent = GetLastTempoEventTickInclusive(ticktime);
        // Formula from .chart format specifications
        return ((ticktime - lastTickEvent) / (double)ChartMetadata.ChartResolution * SECONDS_PER_MINUTE / Events[lastTickEvent].BPMChange) + Events[lastTickEvent].Timestamp;
    }

    #endregion

    #region Modifiers

    /// <summary>
    /// Change the data associated with a beatline event based on a click + drag from the user.
    /// </summary>
    /// <param name="mouseDelta">The difference between the mouse on this frame versus the last frame.</param>
    private void ChangeBPMPositionFromDrag(float mouseDelta)
    {
        WaveformManager.GetCurrentDisplayedWaveformInfo(out var _, out var _, out var timeShown, out var _, out var _);

        var percentOfScreenMoved = mouseDelta / Screen.height; // CHECK THIS
        var timeChange = percentOfScreenMoved * timeShown;

        // Use exclusive function because this needs to find the tempo event before this beatline's tempo event.
        // Inclusive would always return the same event, which causes 0/0 and thus NaN.
        var lastBPMTick = GetLastTempoEventTickExclusive(Tick);

        var newTime = Events[Tick].Timestamp + (float)timeChange;

        // time is measured in seconds so this is beats per second, multiply by 60 to convert to BPM
        // Calculate the new BPM based on the time change
        float newBPS = ((Tick - lastBPMTick) / (float)ChartMetadata.ChartResolution) / (newTime - Events[lastBPMTick].Timestamp);
        float newBPM = (float)Math.Round((newBPS * 60), 3);

        if (newBPM < 0 || newBPM > 1000) return; // BPM can't be negative and event selection gets screwed with when the BPM is too high

        // Write new data: time changes for this beatline's tick, BPM changes for the last tick event.
        Events[Tick] = new BPMData(Events[Tick].BPMChange, newTime);
        Events[lastBPMTick] = new BPMData(newBPM, Events[lastBPMTick].Timestamp);

        // Update rest of dictionary to account for the time change.
        RecalculateTempoEventDictionary(Tick, (float)timeChange);

        // Display the changes
        TempoManager.UpdateBeatlines();
    }

    /// <summary>
    /// Recalculate all tempo events from the tick-time timestamp modified onward.
    /// </summary>
    /// <param name="modifiedTick">The last tick modified to update all future ticks from.</param>
    public static void RecalculateTempoEventDictionary(int modifiedTick = 0)
    {
        SortedDictionary<int, BPMData> outputTempoEventsDict = new();

        var tickEvents = Events.Keys.ToList();
        var positionOfTick = tickEvents.FindIndex(x => x == modifiedTick);
        if (positionOfTick == tickEvents.Count - 1) return; // no events to modify

        // Keep all events before change when creating new dictionary
        for (int i = 0; i <= positionOfTick; i++)
        {
            outputTempoEventsDict.Add(tickEvents[i], new BPMData(Events[tickEvents[i]].BPMChange, Events[tickEvents[i]].Timestamp));
        }
        // Start new data with the song timestamp of the change
        double currentSongTime = outputTempoEventsDict[tickEvents[positionOfTick]].Timestamp;
        for (int i = positionOfTick + 1; i < tickEvents.Count; i++)
        {
            double calculatedTimeSecondDifference = 0;

            if (i > 0)
            {
                // Taken from Chart File Format Specifications -> Calculate time from one pos to the next at a constant bpm
                calculatedTimeSecondDifference =
                (tickEvents[i] - tickEvents[i - 1]) / (double)ChartMetadata.ChartResolution * 60 / BPM.Events[tickEvents[i - 1]].BPMChange;
            }

            currentSongTime += calculatedTimeSecondDifference;
            outputTempoEventsDict.Add(tickEvents[i], new BPMData(Events[tickEvents[i]].BPMChange, (float)currentSongTime));
        }

        Events = outputTempoEventsDict;
    }

    public static void RecalculateTempoEventDictionary(int modifiedTick, float timeChange)
    {
        SortedDictionary<int, BPMData> outputTempoEventsDict = new();

        var tickEvents = BPM.Events.Keys.ToList();
        var positionOfTick = tickEvents.FindIndex(x => x == modifiedTick);
        if (positionOfTick == tickEvents.Count - 1) return; // no events to modify

        // Keep all events before change when creating new dictionary
        for (int i = 0; i <= positionOfTick; i++)
        {
            outputTempoEventsDict.Add(tickEvents[i], new BPMData(Events[tickEvents[i]].BPMChange, Events[tickEvents[i]].Timestamp));
        }

        // Start new data with the song timestamp of the change
        double currentSongTime = outputTempoEventsDict[tickEvents[positionOfTick]].Timestamp;
        for (int i = positionOfTick + 1; i < tickEvents.Count; i++)
        {
            outputTempoEventsDict.Add(tickEvents[i], new BPMData(Events[tickEvents[i]].BPMChange, Events[tickEvents[i]].Timestamp + timeChange));
        }

        Events = outputTempoEventsDict;
    }

    #endregion

    #region Getters

    /// <summary>
    /// Find the last tempo event before a specified tick. Can return the passed in tick if an event exists at that position.
    /// </summary>
    /// <param name="currentTick"></param>
    /// <returns>The tick-time timestamp of the previous tempo event.</returns>
    public static int GetLastTempoEventTickInclusive(int currentTick)
    {
        var tickTimeKeys = Events.Keys.ToList();

        var index = tickTimeKeys.BinarySearch(currentTick);
        if (index < 0) // bitwise complement is negative
        {
            // modify index if the found timestamp is at the end of the array (last tempo event)
            if (~index == tickTimeKeys.Count) index = tickTimeKeys.Count - 1;
            // else just get the index proper 
            else index = ~index - 1; // -1 because ~index is the next timestamp AFTER the start of the window, but we need the one before to properly render beatlines
            return tickTimeKeys[index];
        }
        else
        {
            return tickTimeKeys[index];
        }
    }

    /// <summary>
    /// Find the last tempo event before a specified tick. WILL NOT return the passed in tick if an event exists at that position, and will instead return the true last event.
    /// </summary>
    /// <param name="currentTick"></param>
    /// <returns></returns>
    public static int GetLastTempoEventTickExclusive(int currentTick)
    {
        var tickTimeKeys = Events.Keys.ToList();

        var index = tickTimeKeys.BinarySearch(currentTick);
        if (index <= 0) // bitwise complement is negative
        {
            // modify index if the found timestamp is at the end of the array (last tempo event)
            if (~index == tickTimeKeys.Count) index = tickTimeKeys.Count - 1;
            // else just get the index proper 
            else index = ~index - 1; // -1 because ~index is the next timestamp AFTER the start of the window, but we need the one before to properly render beatlines
            try
            {
                return tickTimeKeys[index];
            }
            catch
            {
                return tickTimeKeys[0]; // if ~index - 1 is -1, then the index should be itself
            }
        }
        else
        {
            return tickTimeKeys[index - 1];
        }
    }
    
    #endregion
}