using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.EventSystems;

public class TimeSignature : Label<TSData>
{
    #region Event Sets

    /// <summary>
    /// Dictionary that contains time signature changes and corresponding tick time positions.
    /// <para>Key = Tick-time position. Value = Numerator (num of beats per bar), Denominator (type of beat)</para>
    /// <para>Example: 192 = 4, 4</para>
    /// <remarks>When writing to file, take the base 2 logarithm of the denominator to get proper .chart format. (where example would show as 192 = TS 4 2)</remarks>
    /// </summary>
    public static SortedDictionary<int, TSData> Events { get; set; } = new();

    public override SortedDictionary<int, TSData> GetEvents()
    {
        return Events;
    }

    public override void SetEvents(SortedDictionary<int, TSData> newEvents)
    {
        Events = newEvents;
    }

    public static HashSet<int> SelectedTSEvents { get; set; } = new();
    public override HashSet<int> GetSelectedEvents()
    {
        return SelectedTSEvents;
    }

    SortedDictionary<int, TSData> tsClipboard = new();
    public override SortedDictionary<int, TSData> GetEventClipboard()
    {
        return tsClipboard;
    }

    #endregion

    #region Unity Functions

    static bool selectionActionsEnabled = false;
    void Awake()
    {
        inputMap = new();
        inputMap.Enable();

        if (!selectionActionsEnabled)
        {
            inputMap.Charting.Delete.performed += x => DeleteSelection();
            inputMap.Charting.Copy.performed += x => CopySelection();
            inputMap.Charting.Paste.performed += x => PasteSelection();
            inputMap.Charting.Cut.performed += x => CutSelection();
            selectionActionsEnabled = true;
        }
    }

    #endregion

    #region Event Handlers

    public override void HandleDragEvent(BaseEventData baseEventData)
    {

    }

    public override void HandleManualEndEdit(string newVal)
    {
        Events[Tick] = ProcessUnsafeTSString(newVal);

        ConcludeManualEdit();
    }

    #endregion

    #region Conversions

    /// <summary>
    /// Take a TS string generated by user and turn it into a dictionary safe tuple
    /// </summary>
    /// <param name="newTS"></param>
    /// <returns></returns>
    TSData ProcessUnsafeTSString(string newTS)
    {
        var currentTS = Events[Tick];
        var seperatedTS = newTS.Split("/");
        if (seperatedTS.Length == 1) return currentTS;

        if (!int.TryParse(seperatedTS[0], out int num)) return currentTS; // dunno why this would fail but i have a feeling

        if (!int.TryParse(seperatedTS[1], out int denom)) return currentTS;
        // TS denoms are only valid as a power of 2 (1, 2, 4, 8, etc.)
        if (!(denom != 0 && (denom & (denom - 1)) == 0)) return currentTS; // taken from https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2 

        return new TSData(num, denom);
    }

    /// <summary>
    /// Calculate the amount of divisions are needed from the chart resolution for each first-division event.
    /// <para>Example: TS = 4/4 -> Returns 1, because chart resolution will need to be divided by 1 to reach the number of ticks between first-division (in this case quarter note) events.</para>
    /// <para>Example: TS = 3/8 -> Returns 2, because res will need to be div by 2 to reach eighth note events.</para>
    /// <para>Example: TS = 2/2 -> Returns 0.5
    /// </summary>
    /// <param name="tick"></param>
    /// <returns>The factor to multiply the chart resolution by to get the first-division tick-time.</returns>
    public static float CalculateDivision(int tick)
    {
        int tsTick = GetLastTSEventTick(tick);
        return (float)TimeSignature.Events[tsTick].Denominator / 4;
    }

    public static int IncreaseByHalfDivision(int tick)
    {
        return (int)(ChartMetadata.ChartResolution / CalculateDivision(tick) / 2);
    }

    public override string ConvertDataToPreviewString()
    {
        return $"{Events[Tick].Numerator} / {Events[Tick].Denominator}";
    }

    #endregion

    #region Calculators

    /// <summary>
    /// Calculate the type of barline a specified tick-time position should be.
    /// </summary>
    /// <param name="beatlineTickTimePos"></param>
    /// <returns>The type of beatline at this tick.</returns>
    public static Beatline.BeatlineType CalculateBeatlineType(int beatlineTickTimePos)
    {
        var lastTSTickTimePos = GetLastTSEventTick(beatlineTickTimePos);
        var tsDiff = beatlineTickTimePos - lastTSTickTimePos; // need absolute distance between the current tick and the origin of the TS event

        // if the difference is divisible by the # of first-division notes in a bar, it's a barline
        if (tsDiff % (ChartMetadata.ChartResolution * (float)Events[lastTSTickTimePos].Numerator / (float)(Events[lastTSTickTimePos].Denominator / 4.0f)) == 0)
        {
            return Beatline.BeatlineType.barline;
        }
        // if it's divisible by the first-division, it's a division line
        else if (tsDiff % (ChartMetadata.ChartResolution / (float)Events[lastTSTickTimePos].Denominator * 4) == 0)
        {
            return Beatline.BeatlineType.divisionLine;
        }
        else if (tsDiff % (ChartMetadata.ChartResolution / ((float)Events[lastTSTickTimePos].Denominator * 2)) == 0)
        {
            return Beatline.BeatlineType.halfDivisionLine;
        }
        return Beatline.BeatlineType.none;
    }

    /// <summary>
    /// Calculate the last time signature event that occurs before a specified tick.
    /// </summary>
    /// <param name="currentTick"></param>
    /// <returns>The tick-time timestamp of the last time signature event.</returns>
    public static int GetLastTSEventTick(int currentTick)
    {
        var tsEvents = Events.Keys.ToList();

        var index = tsEvents.BinarySearch(currentTick);

        int ts;
        if (index < 0) // bitwise complement is negative
        {
            // modify index if the found timestamp is at the end of the array (last tempo event)
            if (~index == tsEvents.Count) index = tsEvents.Count - 1;
            // else just get the index proper 
            else index = ~index - 1; // -1 because ~index is the next timestamp AFTER the start of the window, but we need the one before to properly render beatlines
            try
            {
                ts = tsEvents[index];
            }
            catch
            {
                ts = tsEvents[0]; // if ~index - 1 is -1, then the index should be itself
            }
        }
        else
        {
            ts = tsEvents[index];
        }
        return ts;
    }

    /// <summary>
    /// Calculate the last "1" of a bar from a tick-time timestamp.
    /// </summary>
    /// <param name="currentTick">The tick-time timestamp to evaluate from.</param>
    /// <returns>The tick-time timestamp of the last barline.</returns>
    public static int GetLastBarline(int currentTick)
    {
        var ts = GetLastTSEventTick(currentTick);
        var tickDiff = currentTick - ts;
        var tickInterval = (ChartMetadata.ChartResolution * (float)Events[ts].Numerator) / ((float)Events[ts].Denominator / 4);
        int numIntervals = (int)Math.Floor(tickDiff / tickInterval); // floor is to snap it back to the minimum interval (get LAST barline, not closest)

        return (int)(ts + numIntervals * tickInterval);
    }

    /// <summary>
    /// Calculate the next "1" of a bar from a tick-time timestamp.
    /// </summary>
    /// <param name="currentTick">The tick-time timestamp to evaluate from.</param>
    /// <returns>The tick-time timestamp of the nextd barline.</returns>
    public static int GetNextBarline(int currentTick)
    {
        var ts = GetLastTSEventTick(currentTick);
        var tickDiff = currentTick - ts;
        var tickInterval = (ChartMetadata.ChartResolution * (float)Events[ts].Numerator) / ((float)Events[ts].Denominator / 4);
        int numIntervals = (int)Math.Ceiling(tickDiff / tickInterval);

        return (int)(ts + numIntervals * tickInterval);
    }

    /// <summary>
    /// Calculate the next beatline to be generated from a specified tick-time timestamp.
    /// </summary>
    /// <param name="currentTick"></param>
    /// <returns>The tick-time timestamp of the next beatline event.</returns>
    public static int GetNextBeatlineEvent(int currentTick)
    {
        var ts = GetLastTSEventTick(currentTick);
        var tickDiff = currentTick - ts;
        var tickInterval = ChartMetadata.ChartResolution / ((float)Events[ts].Denominator / 2);
        int numIntervals = (int)Math.Ceiling(tickDiff / tickInterval);

        return (int)(ts + numIntervals * tickInterval);
    }

    public static int GetNextDivisionEvent(int currentTick)
    {
        var ts = GetLastTSEventTick(currentTick);
        var tickDiff = currentTick - ts;
        var tickInterval = ChartMetadata.ChartResolution / ((float)Events[ts].Denominator / 4);
        int numIntervals = (int)Math.Ceiling(tickDiff / tickInterval);

        return (int)(ts + numIntervals * tickInterval);
    }
    
    #endregion
}