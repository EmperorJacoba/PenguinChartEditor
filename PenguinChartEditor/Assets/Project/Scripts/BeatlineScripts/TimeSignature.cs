using System.Collections.Generic;
using TMPro;
using UnityEngine;

public class TimeSignature : Label<(int, int)>
{
    public static HashSet<int> SelectedTSEvents { get; set; } = new();
    bool selectionActionsEnabled = false;

    /// <summary>
    /// Dictionary that contains time signature changes and corresponding tick time positions.
    /// <para>Key = Tick-time position. Value = Numerator (num of beats per bar), Denominator (type of beat)</para>
    /// <para>Example: 192 = 4, 4</para>
    /// <remarks>When writing to file, take the base 2 logarithm of the denominator to get proper .chart format. (where example would show as 192 = TS 4 2)</remarks>
    /// </summary>
    public static SortedDictionary<int, (int, int)> Events { get; set; } = new();

    public override void SetEvents(SortedDictionary<int, (int, int)> newEvents)
    {
        Events = newEvents;
    }

    public override SortedDictionary<int, (int, int)> GetEvents()
    {
        return Events;
    }

    public override HashSet<int> GetSelectedEvents()
    {
        return SelectedTSEvents;
    }

    public override string ConvertDataToPreviewString()
    {
        return $"{Events[Tick].Item1} / {Events[Tick].Item2}";
    }

    void Awake()
    {
        inputMap = new();
        inputMap.Enable();

        if (!selectionActionsEnabled)
        {
            inputMap.Charting.Delete.performed += x => DeleteSelection();
            inputMap.Charting.Copy.performed += x => CopySelection();
            inputMap.Charting.Paste.performed += x => PasteSelection();
            selectionActionsEnabled = true;
        }
    }
    public override SortedDictionary<int, (int, int)> GetEventClipboard()
    {
        return tsClipboard;
    }

    SortedDictionary<int, (int, int)> tsClipboard = new();

    public override void HandleManualEndEdit(string newVal)
    {
        Events[Tick] = ProcessUnsafeTSString(newVal);

        BeatlinePreviewer.editMode = true;
        ConcludeManualEdit();
    }
    
    /// <summary>
    /// Take a TS string generated by user and turn it into a dictionary safe tuple
    /// </summary>
    /// <param name="newTS"></param>
    /// <returns></returns>
    (int, int) ProcessUnsafeTSString(string newTS)
    {
        var currentTS = Events[Tick];
        var seperatedTS = newTS.Split("/");
        if (seperatedTS.Length == 1) return currentTS;

        if (!int.TryParse(seperatedTS[0], out int num)) return currentTS; // dunno why this would fail but i have a feeling

        if (!int.TryParse(seperatedTS[1], out int denom)) return currentTS;
        // TS denoms are only valid as a power of 2 (1, 2, 4, 8, etc.)
        if (!(denom != 0 && (denom & (denom - 1)) == 0)) return currentTS; // taken from https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2 

        return (num, denom);
    }
}