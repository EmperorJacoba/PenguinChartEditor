using UnityEngine;
using System.Collections.Generic;
using System;
using UnityEngine.EventSystems;
using System.Linq;

public class BPMLabel : Label<BPMData>, IDragHandler, IPoolable
{
    #region Event Sets

    public static EventData<BPMData> EventData = new();
    public override EventData<BPMData> GetEventData() => EventData;
    public override SortedDictionary<int, BPMData> GetEventSet() => Tempo.Events;
    public override void SetEvents(SortedDictionary<int, BPMData> newEvents) => Tempo.SetEvents(newEvents);

    public static MoveData<BPMData> moveData = new();
    public override MoveData<BPMData> GetMoveData() => moveData;

    #endregion

    #region Event Handlers

    // Overriden to make sure faulty/inaccurate data is not in Tempo dict after any large modifications
    public override void PasteSelection() => ExecuteWithRecalculate(base.PasteSelection);
    public override void DeleteSelection() => ExecuteWithRecalculate(base.DeleteSelection);
    public override void CreateEvent(int newTick, BPMData newData) => ExecuteWithRecalculate(() => base.CreateEvent(newTick, newData));
    public override void CutSelection() => ExecuteWithRecalculate(base.CutSelection);
    public override void MoveSelection() => ExecuteWithRecalculate(() => base.MoveSelection());
    public override void RefreshEvents() => BPMLane.instance.UpdateEvents();
    public override IPreviewer EventPreviewer => BPMPreviewer.instance;
    public Coroutine destructionCoroutine { get; set; }

    [SerializeField] Anchor anchorIcon;

    void ExecuteWithRecalculate(Action action)
    {
        action();
        Tempo.RecalculateTempoEventDictionary();
        Chart.Refresh();
    }

    public override void HandleManualEndEdit(string newVal)
    {
        try
        {
            Tempo.Events[Tick] = new BPMData(ProcessUnsafeBPMString(newVal), Tempo.Events[Tick].Timestamp);
        }
        catch
        {
            return;
        }

        Tempo.RecalculateTempoEventDictionary(Tick);

        ConcludeManualEdit();
    }

    // This runs alongside MoveSelection() on each label locally if restrictions apply
    // ChangeBPMPositionFromDrag() works a lot simpler with this approach versus overriding the function
    public void OnDrag(PointerEventData data)
    {
        if (Tick == 0) return;
        if (Input.GetKey(KeyCode.LeftControl) && Input.GetKey(KeyCode.LeftAlt))
        {
            ChangeBPMPositionFromDrag(data.delta.y, true);
        }
        else if (Input.GetKey(KeyCode.LeftControl))
        {
            ChangeBPMPositionFromDrag(data.delta.y, false);
        }
    }

    #endregion

    #region Conversions

    /// <summary>
    /// Take a BPM string generated by user and turn it into a dictionary-safe float value
    /// </summary>
    /// <param name="newBPM"></param>
    /// <returns></returns>
    float ProcessUnsafeBPMString(string newBPM)
    {
        var bpmAsFloat = float.Parse(newBPM);
        if (bpmAsFloat == 0 || bpmAsFloat > 1000.0f)
        {
            return Tempo.Events[Tick].BPMChange;
        }
        bpmAsFloat = (float)Math.Round(bpmAsFloat, 3);
        return bpmAsFloat;
    }

    public override string ConvertDataToPreviewString()
    {
        return $"{Tempo.Events[Tick].BPMChange}";
    }

    #endregion

    #region Modifiers

    /// <summary>
    /// Change the data associated with a beatline event based on a click + drag from the user.
    /// </summary>
    /// <param name="mouseDelta">The difference between the mouse on this frame versus the last frame.</param>
    private void ChangeBPMPositionFromDrag(float mouseDelta, bool anchorNextEvent)
    {
        var percentOfScreenMoved = mouseDelta / Screen.height;
        var timeChange = percentOfScreenMoved * Waveform.timeShown;

        // Use exclusive function because this needs to find the tempo event before this beatline's tempo event.
        // Inclusive would always return the same event, which causes 0/0 and thus NaN.
        var lastBPMTick = Tempo.GetLastTempoEventTickExclusive(Tick);

        // anchored bpms are locked
        if (Tempo.AnchoredEvents.Contains(lastBPMTick) || Tempo.AnchoredEvents.Contains(Tick)) return;

        var newTime = Tempo.Events[Tick].Timestamp + (float)timeChange;

        // time is measured in seconds so this is beats per second, multiply by 60 to convert to BPM
        // Calculate the new BPM based on the time change
        float newBPS = ((Tick - lastBPMTick) / (float)Chart.Resolution) / (newTime - Tempo.Events[lastBPMTick].Timestamp);
        float newBPM = (float)Math.Round((newBPS * 60), 3);

        if (newBPM < 0 || newBPM > 1000) return; // BPM can't be negative and event selection gets screwed with when the BPM is too high

        var thisBPM = Tempo.Events[Tick].BPMChange;

        int nextBPMTick;
        try
        {
            nextBPMTick = Tempo.GetNextTempoEventExclusive(Tick);
        }
        catch
        {
            nextBPMTick = Tick;
        }

        if (!anchorNextEvent)
        {
            if (Tempo.AnchoredEvents.Contains(nextBPMTick))
            {
                anchorNextEvent = true;
            }
        }

        // This anchoring logic may present some accuracy errors in the dictionary
        // *should* only be microseconds at most but logic may need to be rethought if possible
        // maybe re-validate dictionary when exporting?
        // Effects currently unknown, but round off should fix it if anything
        // Please remove and re-think if any errors arise from exporting to different software/YARG/Clone Hero
        if (anchorNextEvent && nextBPMTick != Tick)
        {
            // IF you want this to be modified to have anchors furthur than one beat:
            // Apply this logic to the last event before the next anchor event while shifting everything else normally
            // Recalculate range x to y function will probably be needed for that
            float anchoredBPS = ((nextBPMTick - Tick) / (float)Chart.Resolution) / (Tempo.Events[nextBPMTick].Timestamp - newTime);
            float anchoredBPM = (float)Math.Round((anchoredBPS * 60), 3);
            thisBPM = anchoredBPM;
        }

        // Write new data: time changes for this beatline's tick, BPM changes for the last tick event.
        Tempo.Events[Tick] = new BPMData(thisBPM, newTime);
        Tempo.Events[lastBPMTick] = new BPMData(newBPM, Tempo.Events[lastBPMTick].Timestamp);

        // Update rest of dictionary to account for the time change.
        if (!anchorNextEvent) Tempo.RecalculateTempoEventDictionary(Tick, (float)timeChange);

        // Update waveform to reflect changes (needed before full refresh)
        SongTime.InvokeTimeChanged();

        // Display the changes
        Chart.Refresh();
    }

    public override void InitializeLabel()
    {
        base.InitializeLabel();
        if (Tempo.AnchoredEvents.Contains(Tick)) anchorIcon.Opacity = 1f;
        else anchorIcon.Opacity = 0f;
    }

    #endregion
}