using UnityEngine;
using System.Collections.Generic;
using System;
using UnityEngine.EventSystems;
using System.Linq;

public class BPM : Label<BPMData>, IDragHandler
{
    const int SECONDS_PER_MINUTE = 60;

    #region Event Sets

    public static EventData<BPMData> EventData = new();
    public override EventData<BPMData> GetEventData() => EventData;

    static MoveData<BPMData> moveData = new();
    public override MoveData<BPMData> GetMoveData() => moveData;

    public override void SetEvents(SortedDictionary<int, BPMData> newEvents)
    {
        var breakKey = GetFirstVariableEvent(newEvents);
        EventData.Events = newEvents;

        if (!EventData.Events.ContainsKey(0))
        {
            EventData.Events.Add(0, new BPMData(moveData.currentMoveAction.poppedData[0].BPMChange, 0));
        }

        // Safety check before recalculating dictionary
        // When pasting into dictionary, tick 0 might inherit data
        // from a pasted event that has a timestamp which is not 0.
        // Tick 0's timestamp is always 0
        if (EventData.Events[0].Timestamp != 0)
        {
            EventData.Events[0] = new BPMData(EventData.Events[0].BPMChange, 0);
        }

        if (breakKey != -1)
        {
            RecalculateTempoEventDictionary(GetLastTempoEventTickExclusive(breakKey));
        }
    }

    public int GetFirstVariableEvent(SortedDictionary<int, BPMData> newData)
    {
        var currentKeys = EventData.Events.Keys.ToHashSet();
        currentKeys.UnionWith(newData.Keys.ToHashSet());
        currentKeys.OrderBy(x => x);

        foreach (var key in currentKeys)
        {
            try
            {
                if (newData[key] != EventData.Events[key]) // Data has been edited at this point
                {
                    return key;
                }
            }
            catch // The key cannot be accessed in one of the dictionaries (addition/removal)
            {
                return key;
            }
        }
        return -1; // No discrepency
    }

    #endregion

    #region Event Handlers

    public override void PasteSelection() => ExecuteWithRecalculate(base.PasteSelection);
    public override void DeleteSelection() => ExecuteWithRecalculate(base.DeleteSelection);
    public override void CreateEvent(int newTick, BPMData newData) => ExecuteWithRecalculate(() => base.CreateEvent(newTick, newData));
    public override void CutSelection() => ExecuteWithRecalculate(base.CutSelection);
    public override void MoveSelection() => ExecuteWithRecalculate(() => base.MoveSelection());


    void ExecuteWithRecalculate(Action action)
    {
        action();
        RecalculateTempoEventDictionary();
        Chart.Refresh();
    }

    public override void HandleManualEndEdit(string newVal)
    {
        try
        {
            EventData.Events[Tick] = new BPMData(ProcessUnsafeBPMString(newVal), EventData.Events[Tick].Timestamp);
        }
        catch
        {
            return;
        }

        RecalculateTempoEventDictionary(Tick);

        ConcludeManualEdit();
    }

    // This runs alongside MoveSelection() on each label locally if restrictions apply
    // ChangeBPMPositionFromDrag() works a lot simpler with this approach versus overriding the function
    public void OnDrag(PointerEventData data)
    {
        if (Tick == 0) return;
        if (Input.GetKey(KeyCode.LeftControl) && Input.GetKey(KeyCode.LeftAlt))
        {
            ChangeBPMPositionFromDrag(data.delta.y, true);
        }
        else if (Input.GetKey(KeyCode.LeftControl))
        {
            ChangeBPMPositionFromDrag(data.delta.y, false);
        }
    }

    #endregion

    #region Conversions

    /// <summary>
    /// Take a BPM string generated by user and turn it into a dictionary-safe float value
    /// </summary>
    /// <param name="newBPM"></param>
    /// <returns></returns>
    float ProcessUnsafeBPMString(string newBPM)
    {
        var bpmAsFloat = float.Parse(newBPM);
        if (bpmAsFloat == 0 || bpmAsFloat > 1000.0f)
        {
            return EventData.Events[Tick].BPMChange;
        }
        bpmAsFloat = (float)Math.Round(bpmAsFloat, 3);
        return bpmAsFloat;
    }

    public override string ConvertDataToPreviewString()
    {
        return $"{EventData.Events[Tick].BPMChange}";
    }

    /// <summary>
    /// Take a number of seconds (in S.ms form - ex. 61.1 seconds) and convert it to MM:SS.mmm format (where 61.1 returns 01:01.100)
    /// </summary>
    /// <param name="position">The unformatted second count.</param>
    /// <returns>The formatted MM:SS:mmm timestamp of the second position</returns>
    public static string ConvertSecondsToTimestamp(double position)
    {
        var minutes = Math.Floor(position / 60);
        var secondsWithMS = position - minutes * 60;
        var seconds = (int)Math.Floor(secondsWithMS);
        var milliseconds = Math.Round(secondsWithMS - seconds, 3) * 1000;

        string minutesString = minutes.ToString();
        if (minutes < 10)
        {
            minutesString = minutesString.PadLeft(minutesString.Length + 1, '0');
        }

        string secondsString = seconds.ToString();
        if (seconds < 10)
        {
            secondsString = secondsString.PadLeft(2, '0');
        }

        string millisecondsString = milliseconds.ToString();
        if (millisecondsString.Length < 3)
        {
            millisecondsString = millisecondsString.PadRight(3, '0');
        }

        return minutesString + ":" + secondsString + "." + millisecondsString;
    }

    public static int ConvertSecondsToTickTime(float timestamp)
    {
        if (timestamp <= 0)
            return 0;

        else if (timestamp > AudioManager.SongLength)
            return SongTimelineManager.SongLengthTicks;

        // Get parallel lists of the tick-time events and time-second values so that value found with seconds can be converted to a tick-time event
        var tempoTickTimeEvents = EventData.Events.Keys.ToList();
        var tempoTimeSecondEvents = EventData.Events.Values.Select(x => x.Timestamp).ToList();

        // Attempt a binary search for the current timestamp, 
        // which will return a bitwise complement of the index of the next highest timesecond value 
        // OR tempoTimeSecondEvents.Count if there are no more elements
        var index = tempoTimeSecondEvents.BinarySearch(timestamp);

        int lastTickEvent;
        if (index <= 0) // bitwise complement is negative or zero
        {
            // modify index if the found timestamp is at the end of the array (last tempo event)
            if (~index == tempoTimeSecondEvents.Count) index = tempoTimeSecondEvents.Count - 1;
            // else just get the index proper 
            else index = ~index - 1; // -1 because ~index is the next timestamp AFTER the start of the window, but we need the one before to properly render beatlines
            try
            {
                lastTickEvent = tempoTickTimeEvents[index];
            }
            catch
            {
                lastTickEvent = tempoTickTimeEvents[0]; // if ~index - 1 is -1, then the index should be itself
            }
        }
        else
        {
            lastTickEvent = tempoTickTimeEvents[index];
        }

        // Rearranging of .chart format specification distance between two ticks - thanks, algebra class!
        return Mathf.RoundToInt((Chart.Resolution * EventData.Events[lastTickEvent].BPMChange * (float)(timestamp - EventData.Events[lastTickEvent].Timestamp) / SECONDS_PER_MINUTE) + lastTickEvent);
    }

    public static double ConvertTickTimeToSeconds(int ticktime)
    {
        var lastTickEvent = GetLastTempoEventTickInclusive(ticktime);
        // Formula from .chart format specifications
        return ((ticktime - lastTickEvent) / (double)Chart.Resolution * SECONDS_PER_MINUTE / EventData.Events[lastTickEvent].BPMChange) + EventData.Events[lastTickEvent].Timestamp;
    }

    #endregion

    #region Modifiers

    /// <summary>
    /// Change the data associated with a beatline event based on a click + drag from the user.
    /// </summary>
    /// <param name="mouseDelta">The difference between the mouse on this frame versus the last frame.</param>
    private void ChangeBPMPositionFromDrag(float mouseDelta, bool anchorNextEvent)
    {

        var percentOfScreenMoved = mouseDelta / Screen.height;
        var timeChange = percentOfScreenMoved * Waveform.timeShown;

        // Use exclusive function because this needs to find the tempo event before this beatline's tempo event.
        // Inclusive would always return the same event, which causes 0/0 and thus NaN.
        var lastBPMTick = GetLastTempoEventTickExclusive(Tick);

        var newTime = EventData.Events[Tick].Timestamp + (float)timeChange;

        // time is measured in seconds so this is beats per second, multiply by 60 to convert to BPM
        // Calculate the new BPM based on the time change
        float newBPS = ((Tick - lastBPMTick) / (float)Chart.Resolution) / (newTime - EventData.Events[lastBPMTick].Timestamp);
        float newBPM = (float)Math.Round((newBPS * 60), 3);

        if (newBPM < 0 || newBPM > 1000) return; // BPM can't be negative and event selection gets screwed with when the BPM is too high

        var thisBPM = EventData.Events[Tick].BPMChange;

        int nextBPMTick;
        try
        {
            nextBPMTick = GetNextTempoEventExclusive(Tick);
        }
        catch
        {
            nextBPMTick = Tick;
        }

        // This anchoring logic may present some accuracy errors in the dictionary
        // *should* only be microseconds at most but logic may need to be rethought if possible
        // maybe re-validate dictionary when exporting?
        // Effects currently unknown, but round off should fix it if anything
        // Please remove and re-think if any errors arise from exporting to different software/YARG/Clone Hero
        if (anchorNextEvent && nextBPMTick != Tick)
        {
            // IF you want this to be modified to have anchors furthur than one beat:
            // Apply this logic to the last event before the next anchor event while shifting everything else normally
            // Recalculate range x to y function will probably be needed for that
            float anchoredBPS = ((nextBPMTick - Tick) / (float)Chart.Resolution) / (EventData.Events[nextBPMTick].Timestamp - newTime);
            float anchoredBPM = (float)Math.Round((anchoredBPS * 60), 3);
            thisBPM = anchoredBPM;
        }

        // Write new data: time changes for this beatline's tick, BPM changes for the last tick event.
        EventData.Events[Tick] = new BPMData(thisBPM, newTime);
        EventData.Events[lastBPMTick] = new BPMData(newBPM, EventData.Events[lastBPMTick].Timestamp);

        // Update rest of dictionary to account for the time change.
        if (!anchorNextEvent) RecalculateTempoEventDictionary(Tick, (float)timeChange);

        // Display the changes
        Chart.Refresh();
    }

    /// <summary>
    /// Recalculate all tempo events from the tick-time timestamp modified onward.
    /// </summary>
    /// <param name="modifiedTick">The last tick modified to update all future ticks from.</param>
    public static void RecalculateTempoEventDictionary(int modifiedTick = 0)
    {
        SortedDictionary<int, BPMData> outputTempoEventsDict = new();

        var tickEvents = EventData.Events.Keys.ToList();
        var positionOfTick = tickEvents.FindIndex(x => x == modifiedTick);
        if (positionOfTick == tickEvents.Count - 1) return; // no events to modify

        // Keep all events before change when creating new dictionary
        for (int i = 0; i <= positionOfTick; i++)
        {
            outputTempoEventsDict.Add(tickEvents[i], new BPMData(EventData.Events[tickEvents[i]].BPMChange, EventData.Events[tickEvents[i]].Timestamp));
        }
        // Start new data with the song timestamp of the change
        double currentSongTime = outputTempoEventsDict[tickEvents[positionOfTick]].Timestamp;
        for (int i = positionOfTick + 1; i < tickEvents.Count; i++)
        {
            double calculatedTimeSecondDifference = 0;

            if (i > 0)
            {
                // Taken from Chart File Format Specifications -> Calculate time from one pos to the next at a constant bpm
                calculatedTimeSecondDifference =
                (tickEvents[i] - tickEvents[i - 1]) / (double)Chart.Resolution * 60 / EventData.Events[tickEvents[i - 1]].BPMChange;
            }

            currentSongTime += calculatedTimeSecondDifference;
            outputTempoEventsDict.Add(tickEvents[i], new BPMData(EventData.Events[tickEvents[i]].BPMChange, (float)currentSongTime));
        }

        EventData.Events = outputTempoEventsDict;
    }

    public static void RecalculateTempoEventDictionary(int modifiedTick, float timeChange)
    {
        SortedDictionary<int, BPMData> outputTempoEventsDict = new();

        var tickEvents = EventData.Events.Keys.ToList();
        var positionOfTick = tickEvents.FindIndex(x => x == modifiedTick);
        if (positionOfTick == tickEvents.Count - 1) return; // no events to modify

        // Keep all events before change when creating new dictionary
        for (int i = 0; i <= positionOfTick; i++)
        {
            outputTempoEventsDict.Add(tickEvents[i], new BPMData(EventData.Events[tickEvents[i]].BPMChange, EventData.Events[tickEvents[i]].Timestamp));
        }

        // Start new data with the song timestamp of the change
        double currentSongTime = outputTempoEventsDict[tickEvents[positionOfTick]].Timestamp;
        for (int i = positionOfTick + 1; i < tickEvents.Count; i++)
        {
            outputTempoEventsDict.Add(tickEvents[i], new BPMData(EventData.Events[tickEvents[i]].BPMChange, EventData.Events[tickEvents[i]].Timestamp + timeChange));
        }

        EventData.Events = outputTempoEventsDict;
    }

    #endregion

    #region Getters

    /// <summary>
    /// Find the last tempo event before a specified tick. Can return the passed in tick if an event exists at that position.
    /// </summary>
    /// <param name="currentTick"></param>
    /// <returns>The tick-time timestamp of the previous tempo event.</returns>
    public static int GetLastTempoEventTickInclusive(int currentTick)
    {
        if (currentTick < 0) return 0;
        var tickTimeKeys = EventData.Events.Keys.ToList();

        var index = tickTimeKeys.BinarySearch(currentTick);

        if (index >= 0) return tickTimeKeys[index]; // bitwise complement is negative

        // modify index if the found timestamp is at the end of the array (last tempo event)
        if (~index == tickTimeKeys.Count) index = tickTimeKeys.Count - 1;
        // else just get the index proper 
        else index = ~index - 1; // -1 because ~index is the next timestamp AFTER the start of the window, but we need the one before to properly render beatlines

        return tickTimeKeys[index];
    }

    /// <summary>
    /// Find the last tempo event before a specified tick. WILL NOT return the passed in tick if an event exists at that position, and will instead return the true last event.
    /// </summary>
    /// <param name="currentTick"></param>
    /// <returns></returns>
    public static int GetLastTempoEventTickExclusive(int currentTick)
    {
        var tickTimeKeys = EventData.Events.Keys.ToList();

        var index = tickTimeKeys.BinarySearch(currentTick);

        // bitwise complement is negative
        if (index > 0) return tickTimeKeys[index - 1];

        // modify index if the found timestamp is at the end of the array (last tempo event)
        if (~index == tickTimeKeys.Count) index = tickTimeKeys.Count - 1;
        // else just get the index proper 
        else index = ~index - 1; // -1 because ~index is the next timestamp AFTER the start of the window, but we need the one before to properly render beatlines
        try
        {
            return tickTimeKeys[index];
        }
        catch
        {
            return tickTimeKeys[0]; // if ~index - 1 is -1, then the index should be itself
        }
    }

    public static int GetNextTempoEventExclusive(int currentTick)
    {
        var tickTimeKeys = EventData.Events.Keys.ToList();

        var index = tickTimeKeys.BinarySearch(currentTick);

        // modify index if the found timestamp is at the end of the array (last tempo event)
        if (~index == tickTimeKeys.Count) return tickTimeKeys.Count - 1;

        // bitwise complement is negative
        if (index > 0) return tickTimeKeys[index + 1];

        // else just get the index proper 
        else index = ~index + 1; // -1 because ~index is the next timestamp AFTER the start of the window, but we need the one before to properly render beatlines
        try
        {
            return tickTimeKeys[index];
        }
        catch
        {
            return tickTimeKeys[0]; // if ~index - 1 is -1, then the index should be itself
        }
    }

    #endregion

    public void UpdatePosition(double percentOfScreen, float screenHeight)
    {
        var yScreenProportion = (float)percentOfScreen * screenHeight;
        transform.localPosition = new Vector3(transform.localPosition.x, yScreenProportion - (LabelRectTransform.rect.height / 2));
    }
}