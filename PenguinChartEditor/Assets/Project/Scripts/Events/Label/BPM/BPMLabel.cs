using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;

public class BPMLabel : Label<BPMData>, IDragHandler, IPoolable
{
    private const int SECONDS_PER_MINUTE = 60;
    private const int BPM_DIGIT_COUNT = 3;
    #region Event Sets
    public override SelectionSet<BPMData> Selection => Chart.SyncTrackInstrument.bpmSelection;
    public override LaneSet<BPMData> LaneData => Chart.SyncTrackInstrument.TempoEvents;
    public override MoveData<BPMData> GetMoveData() => Chart.SyncTrackInstrument.bpmMoveData;
    public override IInstrument ParentInstrument => Chart.SyncTrackInstrument;

    #endregion

    public override int Tick
    {
        get
        {
            return _tick;
        }
    }
    int _tick;

    public void InitializeEvent(int tick)
    {
        _tick = tick;
        Visible = true;
        InitializeLabel();
        UpdatePosition(Waveform.GetWaveformRatio(_tick), Chart.instance.SceneDetails.HighwayLength);

        // w/o this the input field will stay on if you delete it while editing
        // leading to jank where the input field for the next event is visible
        // but was never edited
        if (justDeleted) DeactivateManualInput(); // does not work properly
    }


    #region Event Handlers

    // Overriden to make sure faulty/inaccurate data is not in Tempo dict after any large modifications
    public override void DeleteSelection() => ExecuteWithRecalculate(base.DeleteSelection);
    public override void CreateEvent(int newTick, BPMData newData) => ExecuteWithRecalculate(() => base.CreateEvent(newTick, newData));
    public override void MoveSelection() => ExecuteWithRecalculate(() => base.MoveSelection());
    public override void RefreshLane() => BPMLane.instance.UpdateEvents();
    public override void SustainSelection() { return; }
    public override void CompleteSustain()
    {
        return;
    }
    public override IPreviewer EventPreviewer => BPMPreviewer.instance;
    public Coroutine destructionCoroutine { get; set; }

    [SerializeField] Anchor anchorIcon;

    void ExecuteWithRecalculate(Action action)
    {
        action();
        Chart.SyncTrackInstrument.RecalculateTempoEventDictionary();
        Chart.Refresh();
    }

    public override void HandleManualEndEdit(string newVal)
    {
        try
        {
            Chart.SyncTrackInstrument.TempoEvents[Tick] = new BPMData(ProcessUnsafeBPMString(newVal), Chart.SyncTrackInstrument.TempoEvents[Tick].Timestamp, Chart.SyncTrackInstrument.TempoEvents[Tick].Anchor);
        }
        catch
        {
            return;
        }

        Chart.SyncTrackInstrument.RecalculateTempoEventDictionary(Tick);

        ConcludeManualEdit();
    }

    // This runs alongside MoveSelection() on each label locally if restrictions apply
    // ChangeBPMPositionFromDrag() works a lot simpler with this approach versus overriding the function
    public void OnDrag(PointerEventData data)
    {
        if (Tick == 0) return;
        if (Input.GetKey(KeyCode.LeftControl) && Input.GetKey(KeyCode.LeftAlt))
        {
            ChangeBPMPositionFromDrag(data.delta.y, true);
        }
        else if (Input.GetKey(KeyCode.LeftControl))
        {
            ChangeBPMPositionFromDrag(data.delta.y, false);
        }
    }

    #endregion

    #region Conversions

    /// <summary>
    /// Take a BPM string generated by user and turn it into a dictionary-safe float value
    /// </summary>
    /// <param name="newBPM"></param>
    /// <returns></returns>
    float ProcessUnsafeBPMString(string newBPM)
    {
        var bpmAsFloat = float.Parse(newBPM);
        if (bpmAsFloat == 0 || bpmAsFloat > 1000.0f)
        {
            return Chart.SyncTrackInstrument.TempoEvents[Tick].BPMChange;
        }
        bpmAsFloat = (float)Math.Round(bpmAsFloat, 3);
        return bpmAsFloat;
    }

    public override string ConvertDataToPreviewString()
    {
        return $"{Chart.SyncTrackInstrument.TempoEvents[Tick].BPMChange}";
    }

    #endregion

    #region Modifiers

    /// <summary>
    /// Change the data associated with a beatline event based on a click + drag from the user.
    /// </summary>
    /// <param name="mouseDelta">The difference between the mouse on this frame versus the last frame.</param>
    private void ChangeBPMPositionFromDrag(float mouseDelta, bool anchorNextEvent)
    {
        var percentOfScreenMoved = mouseDelta / Screen.height;
        var timeChange = percentOfScreenMoved * Waveform.timeShown;

        // Use exclusive function because this needs to find the tempo event before this beatline's tempo event.
        // Inclusive would always return the same event, which causes 0/0 and thus NaN.
        var lastBPMTick = Chart.SyncTrackInstrument.TempoEvents.GetPreviousTickEventInLane(Tick);

        if (lastBPMTick == LaneSet<BPMData>.NO_TICK_EVENT) return;

        // anchored bpms are locked - do not edit with dragging
        if (Chart.SyncTrackInstrument.TempoEvents[lastBPMTick].Anchor || Chart.SyncTrackInstrument.TempoEvents[Tick].Anchor) return;

        var newTime = Chart.SyncTrackInstrument.TempoEvents[Tick].Timestamp + (float)timeChange;

        // time is measured in seconds so this is beats per second, multiply by 60 to convert to BPM
        // Calculate the new BPM based on the time change
        float newBPS = ((Tick - lastBPMTick) / (float)Chart.Resolution) / (newTime - Chart.SyncTrackInstrument.TempoEvents[lastBPMTick].Timestamp);
        float newBPM = (float)Math.Round((newBPS * SECONDS_PER_MINUTE), BPM_DIGIT_COUNT);

        var thisBPM = Chart.SyncTrackInstrument.TempoEvents[Tick].BPMChange;

        int nextBPMTick = Chart.SyncTrackInstrument.TempoEvents.GetNextTickEventInLane(Tick);

        if (!anchorNextEvent && nextBPMTick != LaneSet<BPMData>.NO_TICK_EVENT)
        {
            if (Chart.SyncTrackInstrument.TempoEvents[nextBPMTick].Anchor)
            {
                anchorNextEvent = true;
            }
        }

        if (anchorNextEvent)
        {
            thisBPM = Chart.SyncTrackInstrument.CalculateLastBPMBeforeAnchor(Tick, newTime, nextBPMTick);
        }

        if (!Chart.SyncTrackInstrument.IsTickInBounds(newBPM)) return;
        if (!Chart.SyncTrackInstrument.IsTickInBounds(thisBPM)) return;

        // Write new data: time changes for this beatline's tick, BPM changes for the last tick event.
        Chart.SyncTrackInstrument.TempoEvents[Tick] = new BPMData(thisBPM, newTime, Chart.SyncTrackInstrument.TempoEvents[Tick].Anchor);
        Chart.SyncTrackInstrument.TempoEvents[lastBPMTick] = new BPMData(newBPM, Chart.SyncTrackInstrument.TempoEvents[lastBPMTick].Timestamp, Chart.SyncTrackInstrument.TempoEvents[Tick].Anchor);

        // Update rest of dictionary to account for the time change. Anchors are not moved, so no need to update.
        if (!anchorNextEvent) Chart.SyncTrackInstrument.RecalculateTempoEventDictionary(Tick, (float)timeChange);

        // Update waveform to reflect changes (needed before full refresh)
        SongTime.InvokeTimeChanged();

        // Display the changes
        Chart.Refresh();
    }

    public override void InitializeLabel()
    {
        base.InitializeLabel();
        if (Chart.SyncTrackInstrument.TempoEvents[Tick].Anchor) anchorIcon.Opacity = 1f;
        else anchorIcon.Opacity = 0f;
    }

    #endregion
}