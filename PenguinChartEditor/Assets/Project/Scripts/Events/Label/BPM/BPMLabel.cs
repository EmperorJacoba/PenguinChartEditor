using System;
using UnityEngine;
using UnityEngine.EventSystems;

public class BPMLabel : Label<BPMData>, IDragHandler, IPoolable
{
    #region Constants

    private const int SECONDS_PER_MINUTE = 60;
    private const int BPM_DIGIT_COUNT = 3;

    public override int Lane => (int)SyncTrackInstrument.LaneOrientation.bpm;

    #endregion

    #region Event Sets / Properties

    public override SelectionSet<BPMData> Selection => Chart.SyncTrackInstrument.bpmSelection;
    public override LaneSet<BPMData> LaneData => Chart.SyncTrackInstrument.TempoEvents;
    public override IInstrument ParentInstrument => Chart.SyncTrackInstrument;


    [SerializeField] Anchor anchorIcon;
    public Coroutine destructionCoroutine { get; set; }

    #endregion

    public void InitializeEvent(int tick)
    {
        base.InitializeLabel(tick);
        if (Chart.SyncTrackInstrument.TempoEvents[Tick].Anchor) anchorIcon.Opacity = 1f;
        else anchorIcon.Opacity = 0f;
    }

    #region Event Handlers

    // Overriden to make sure faulty/inaccurate data is not in Tempo dict after any large modifications
    public override void CreateEvent(int newTick, BPMData newData) => ExecuteWithRecalculate(() => base.CreateEvent(newTick, newData));

    void ExecuteWithRecalculate(Action action)
    {
        action();
        Chart.SyncTrackInstrument.RecalculateTempoEventDictionary();
        Chart.InPlaceRefresh();
    }

    #endregion

    #region Conversions

    /// <summary>
    /// Take a BPM string generated by user and turn it into a dictionary-safe float value
    /// </summary>
    /// <param name="newBPM"></param>
    /// <returns></returns>
    protected override BPMData ProcessUnsafeLabelString(string newBPM)
    {
        var existingData = Chart.SyncTrackInstrument.TempoEvents[Tick];

        var bpmAsFloat = float.Parse(newBPM);
        if (bpmAsFloat == 0 || bpmAsFloat > 1000.0f)
        {
            return Chart.SyncTrackInstrument.TempoEvents[Tick];
        }
        bpmAsFloat = (float)Math.Round(bpmAsFloat, 3);

        return new(bpmAsFloat, existingData.Timestamp, existingData.Anchor);
    }

    protected override string ConvertDataToPreviewString()
    {
        return $"{Chart.SyncTrackInstrument.TempoEvents[Tick].BPMChange}";
    }

    #endregion

    #region Change BPM

    // This runs alongside MoveSelection() on each label locally if restrictions apply
    // ChangeBPMPositionFromDrag() works a lot simpler with this approach versus overriding the function
    public void OnDrag(PointerEventData data)
    {
        if (Tick == 0 || !Input.GetKey(KeyCode.LeftControl)) return;

        ChangeBPMPositionFromDrag(
            mouseDelta: data.delta.y,
            anchorNextEvent: Input.GetKey(KeyCode.LeftAlt)
            );
    }

    /// <summary>
    /// Change the data associated with a beatline event based on a click + drag from the user.
    /// </summary>
    /// <param name="mouseDelta">The difference between the mouse on this frame versus the last frame.</param>
    private void ChangeBPMPositionFromDrag(float mouseDelta, bool anchorNextEvent)
    {
        var percentOfScreenMoved = mouseDelta / Screen.height;
        var timeChange = percentOfScreenMoved * Waveform.timeShown;

        // Use exclusive function because this needs to find the tempo event before this beatline's tempo event.
        // Inclusive would always return the same event, which causes 0/0 and thus NaN.
        var lastBPMTick = Chart.SyncTrackInstrument.TempoEvents.GetPreviousTickEventInLane(Tick);

        if (lastBPMTick == LaneSet<BPMData>.NO_TICK_EVENT) return;

        // anchored bpms are locked - do not edit with dragging
        if (Chart.SyncTrackInstrument.TempoEvents[lastBPMTick].Anchor || Chart.SyncTrackInstrument.TempoEvents[Tick].Anchor) return;

        var newTime = Chart.SyncTrackInstrument.TempoEvents[Tick].Timestamp + (float)timeChange;

        // time is measured in seconds so this is beats per second, multiply by 60 to convert to BPM
        // Calculate the new BPM based on the time change
        float newBPS = ((Tick - lastBPMTick) / (float)Chart.Resolution) / (newTime - Chart.SyncTrackInstrument.TempoEvents[lastBPMTick].Timestamp);
        float newBPM = (float)Math.Round((newBPS * SECONDS_PER_MINUTE), BPM_DIGIT_COUNT);

        var thisBPM = Chart.SyncTrackInstrument.TempoEvents[Tick].BPMChange;

        int nextBPMTick = Chart.SyncTrackInstrument.TempoEvents.GetNextTickEventInLane(Tick);

        if (!anchorNextEvent && nextBPMTick != LaneSet<BPMData>.NO_TICK_EVENT)
        {
            if (Chart.SyncTrackInstrument.TempoEvents[nextBPMTick].Anchor)
            {
                anchorNextEvent = true;
            }
        }

        if (anchorNextEvent)
        {
            thisBPM = Chart.SyncTrackInstrument.CalculateLastBPMBeforeAnchor(Tick, newTime, nextBPMTick);
        }

        if (!Chart.SyncTrackInstrument.IsTickInBounds(newBPM)) return;
        if (!Chart.SyncTrackInstrument.IsTickInBounds(thisBPM)) return;

        // Write new data: time changes for this beatline's tick, BPM changes for the last tick event.
        Chart.SyncTrackInstrument.TempoEvents[Tick] = new BPMData(thisBPM, newTime, Chart.SyncTrackInstrument.TempoEvents[Tick].Anchor);
        Chart.SyncTrackInstrument.TempoEvents[lastBPMTick] = new BPMData(newBPM, Chart.SyncTrackInstrument.TempoEvents[lastBPMTick].Timestamp, Chart.SyncTrackInstrument.TempoEvents[Tick].Anchor);

        // Update rest of dictionary to account for the time change. Anchors are not moved, so no need to update.
        if (!anchorNextEvent) Chart.SyncTrackInstrument.RecalculateTempoEventDictionary(Tick, (float)timeChange);

        SongTime.InvokeTimeChanged();

        // Display the changes
        Chart.InPlaceRefresh();
    }

    #endregion
}