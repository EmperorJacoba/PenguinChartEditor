using System.Collections.Generic;
using UnityEngine;

public class TSLabel : Label<TSData>, IPoolable
{
    #region Event Sets
    public override SelectionSet<TSData> Selection => Chart.SyncTrackInstrument.tsSelection;
    public override LaneSet<TSData> LaneData => Chart.SyncTrackInstrument.TimeSignatureEvents;
    public override void RefreshLane() => TSLane.instance.UpdateEvents();
    public override IPreviewer EventPreviewer => TSPreviewer.instance;
    public override IInstrument ParentInstrument => Chart.SyncTrackInstrument;
    public Coroutine destructionCoroutine { get; set; }
    [SerializeField] Warning tsWarningAlert;

    #endregion

    public override int Tick
    {
        get
        {
            return _tick;
        }
    }
    int _tick;

    public void InitializeEvent(int tick)
    {
        _tick = tick;
        Visible = true;
        InitializeLabel();
        UpdatePosition(Waveform.GetWaveformRatio(_tick), Chart.instance.SceneDetails.HighwayLength);

        tsWarningAlert.Visible = !Chart.SyncTrackInstrument.IsEventValid(tick);

        // w/o this the input field will stay on if you delete it while editing
        // leading to jank where the input field for the next event is visible
        // but was never edited
        if (justDeleted) DeactivateManualInput(); // does not work properly
    }

    #region Event Handlers
    public override void HandleManualEndEdit(string newVal)
    {
        Chart.SyncTrackInstrument.TimeSignatureEvents[Tick] = ProcessUnsafeTSString(newVal);

        ConcludeManualEdit();
    }

    #endregion

    public override void SustainSelection() { return; }
    public override void CompleteSustain()
    {
        return;
    }

    #region Conversions

    /// <summary>
    /// Take a TS string generated by user and turn it into a dictionary safe tuple
    /// </summary>
    /// <param name="newTS"></param>
    /// <returns></returns>
    TSData ProcessUnsafeTSString(string newTS)
    {
        var currentTS = Chart.SyncTrackInstrument.TimeSignatureEvents[Tick];
        var seperatedTS = newTS.Split("/");
        if (seperatedTS.Length == 1) return currentTS;

        if (!int.TryParse(seperatedTS[0], out int num)) return currentTS; // dunno why this would fail but i have a feeling

        if (!int.TryParse(seperatedTS[1], out int denom)) return currentTS;
        // TS denoms are only valid as a power of 2 (1, 2, 4, 8, etc.)
        if (!(denom != 0 && (denom & (denom - 1)) == 0)) return currentTS; // taken from https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2 

        return new TSData(num, denom);
    }

    public override string ConvertDataToPreviewString()
    {
        return $"{Chart.SyncTrackInstrument.TimeSignatureEvents[Tick].Numerator} / {Chart.SyncTrackInstrument.TimeSignatureEvents[Tick].Denominator}";
    }

    #endregion
}